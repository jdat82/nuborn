// allow inheritance
require("../common/inheritance");

// load grunt API
var grunt = require("grunt");

// load path API
var nodePath = require("path");

// system path separator
var sep = nodePath.sep;

// scopes constants
var scopes = require("../common/Constants").scopes;

// utility methods
var Util = require("../common/Util");

/**
* @class JavascriptProcessor
* It's job is to process the "javascript" configuration part.
*/
var JavascriptProcessor = Object.subClass(
{
    /**
    * Generate concatenad, minified, optimized javascript files.
    * @param targets the list of targets (android/ios/web...) 
    * @param configuration javascript configuration part in gruntfile
    * @param scope current build scope
    */
    process: function(targets, configuration, scope)
    {

    	grunt.log.writeln("js processing with scope " + scope);

		// get references to possible targets 
		var android = targets.android;
		var ios = targets.ios;
		var web = targets.web;

		// if the build concerns the libs and it is asked to rebuild nuborn
		if (scope === scopes.libs && configuration.buildNubornFirst) {
			// build nuborn
			this.buildNubornJS();
		}

		// get grunt config
		var config = grunt.config.data;
		// get the existing closure compiler config, or a new one 
		config["closure-compiler"] = config["closure-compiler"] || {};
		// get a reference to the configuration of closure compiler
		var closure = config["closure-compiler"];
		// create and initialize the default target
		var target = {
			closurePath: "closure"
		};
		// Create array of Closure Targets
		var nubornClosureTargets = [];
		// define a default closure configuration
		var defaultConfiguration = {
			compilation_level: scope === scopes.app ? "SIMPLE_OPTIMIZATIONS" : "WHITESPACE_ONLY"
		};
		// create the target options
		target.options = Util.jQueryExtend(true, {}, defaultConfiguration, configuration.options);

		// Check if a separate build is needed
		var separate = false;
		if (android) {
			separate = separate || this.needsSeparateBuilds(configuration.android);
		}
		if (ios) {
			separate = separate || this.needsSeparateBuilds(configuration.ios);
		}
		if (web) {
			separate = separate || this.needsSeparateBuilds(configuration.web);
		}

		// sets the output file name
		var output = configuration.output ? configuration.output : "output.min.js";

		// get the timestamp to avoid potential conflicts
		var suffix = new Date().getTime();

		// if separate builds are needed
		if (separate) {
			// build all separately
			if (android) {
				closure["nuborn-android"] = this.buildClosureTarget("android", target, output, configuration);
				nubornClosureTargets.push("closure-compiler:nuborn-android");
			}
			if (ios) {
				closure["nuborn-ios"] = this.buildClosureTarget("ios", target, output, configuration);
				nubornClosureTargets.push("closure-compiler:nuborn-ios");
			}
			if (web) {
				closure["nuborn-web"] = this.buildClosureTarget("web", target, output, configuration);
				nubornClosureTargets.push("closure-compiler:nuborn-web");
			}
		} else {
			// create the temp folder
			grunt.file.mkdir("build" + sep + "closure" + suffix);
			// build one and copy
			closure["nuborn-target"] = this.buildClosureTarget("closure" + suffix, target, output, configuration);
			nubornClosureTargets.push("closure-compiler:nuborn-target");
		}

		/**
		 * RUN CLOSURE COMPILER TASKS
		 */
		grunt.task.run(nubornClosureTargets);

		/**
		 * COPY REPORTS AND FILES FOR NON SEPARATE BUILDS
		 */
		if (separate) {
			if (android) {
				grunt.task.run("nuborn-move:" + closure["nuborn-android"].jsOutputFile + ".report.txt:closure" + sep + "reports" + sep + "android.report.txt");
			}
			if (ios) {
				grunt.task.run("nuborn-move:" + closure["nuborn-ios"].jsOutputFile + ".report.txt:closure" + sep + "reports" + sep + "ios.report.txt");
			}
			if (web) {
				grunt.task.run("nuborn-move:" + closure["nuborn-web"].jsOutputFile + ".report.txt:closure" + sep + "reports" + sep + "web.report.txt");
			}
		} else {
			if (android) {
				var androidOutput = configuration.android && configuration.android.output ? configuration.android.output : output;
				grunt.task.run("nuborn-copy:build" + sep + "closure" + suffix + sep + output + ":build" + sep + "android" + sep + androidOutput);
			}
			if (ios) {
				var iosOutput = configuration.ios && configuration.ios.output ? configuration.ios.output : output;
				grunt.task.run("nuborn-copy:build" + sep + "closure" + suffix + sep + output + ":build" + sep + "ios" + sep + iosOutput);
			}
			if (web) {
				var webOutput = configuration.web && configuration.web.output ? configuration.web.output : output;
				grunt.task.run("nuborn-copy:build" + sep + "closure" + suffix + sep + output + ":build" + sep + "web" + sep + webOutput);
			}

			grunt.task.run("nuborn-copy:build" + sep + "closure" + suffix + sep + output + ".report.txt:closure" + sep + "reports" + sep + output + ".report.txt");

			grunt.task.run("nuborn-delete:build" + sep + "closure" + suffix);

			grunt.log.writeln(JSON.stringify(config["closure-compiler"]));
		}

    },

    needsSeparateBuilds: function(target) 
    {
		// if the target is not specified, no need to build it separately
		if (!target) {
			return false;
		}
		// if options is specified AND is not empty, needs a separate build
		if (target.options && Object.keys(target.options).length) {
			return true;
		}
		// if patterns is specified AND is not empty, needs a separate build
		if (target.patterns && Object.keys(target.patterns).length) {
			return true;
		}
		// otherwise do not need a separate build
		return false;
	},

	buildNubornJS: function()
	{
		// get grunt configuration
		var config = grunt.config.data;
		// get existing closure configuration or a new one
		config["closure-compiler"] = config["closure-compiler"] || {};
		// set a reference to the closure configuration
		var closure = config["closure-compiler"];
		// create a new target for closure compiler
		var nuborn = {};
		closure["nuborn-nuborn"] = nuborn;
		// path to closure compiler
		nuborn.closurePath = "closure";
		// build all except nuborn.js itself
		nuborn.js = [
				scopes.libs + sep + "Nuborn" + sep + "**" + sep + "*.js",
				"!libs" + sep + "Nuborn" + sep + "nuborn.js"
		];
		// build nuborn.js
		nuborn.jsOutputFile = scopes.libs + sep + "Nuborn" + sep + "nuborn.js";
		// set closure compiler options
		nuborn.options = {
			compilation_level: "SIMPLE_OPTIMIZATIONS"
		};
		// run the task
		grunt.task.run("closure-compiler:nuborn-nuborn");
		// move the report file
		grunt.task.run("nuborn-move:libs" + sep + "Nuborn" + sep + "nuborn.js.report.txt:closure" + sep + "reports" + sep + "nuborn.report.txt");
	},

	buildClosureTarget: function(targetName, parent, output, configuration) 
	{
		// Clone the parent target
		var target = Util.jQueryExtend(true, {}, parent);
		// initialize target sources with the common one or a new one
		var targetSources = [].concat(configuration.patterns ? configuration.patterns : []);
		// treat target specific configuration
		if (configuration[targetName]) {
			// get the configuration for the current target
			var targetConfiguration = configuration[targetName];
			// extends options with target's options
			Util.jQueryExtend(true, target.options, targetConfiguration.options);

			// treat target specific output file
			if (targetConfiguration.output) {
				target.jsOutputFile = "build" + sep + targetName + sep + targetConfiguration.output;
			} else {
				target.jsOutputFile = "build" + sep + targetName + sep + output;
			}

			// add the target sources to the initial sources
			if (targetConfiguration.patterns) {
				targetSources = targetSources.concat(targetConfiguration.patterns);
			}

		} else {
			// just set the output file
			target.jsOutputFile = "build" + sep + targetName + sep + output;
		}
		// set the js property of closure with target sources
		target.js = targetSources;
		// return the target
		return target;
	}

});

module.exports = JavascriptProcessor;
