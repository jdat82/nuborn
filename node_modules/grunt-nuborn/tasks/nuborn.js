/*
 * grunt-nuborn
 * https://github.com/jrob/grunt-nuborn
 *
 * Copyright (c) 2013 Jim Robs
 * Licensed under the MIT license.
 */

'use strict';

module.exports = function(grunt) {

	/**
	 * Loading task dependencies
	 */
	grunt.loadNpmTasks('grunt-contrib-sass');
	grunt.loadNpmTasks('grunt-closure-compiler');
	grunt.loadNpmTasks('grunt-contrib-copy');

	/**
	 * Register task Nuborn
	 */
	grunt.registerMultiTask('nuborn', 'Your task description goes here.', function() {
		var extension = grunt.option("extension");

		if(!extension){
			grunt.log.writeln("No extension option is provided.");
			return;
		}

		var target = grunt.option("libs") ? "libs" : "app";
		switch(extension){
			case "js":
				if(this.data.javascript && this.data.javascript[target]){
					launchJavascriptBuild(this.data.targets, this.data.javascript[target], target);
				} else{
					grunt.log.writeln("Javascript "+target+" configuration is missing");
				}
				break;

			case "scss":
				if(this.data.css && this.data.css[target]){
					grunt.launchCSSBuild(this.data.targets, this.data.css[target], target);
				} else{
					grunt.log.writeln("CSS "+target+" configuration is missing");
				}
				break;

			case "html":
				if(this.data.html && this.data.html[target]){
					grunt.launchHTMLBuild(this.data.targets, this.data.html[target], target);
				} else{
					grunt.log.writeln("HTML "+target+" configuration is missing");
				}
				break;

			default:
				grunt.log.writeln("The extension provided is not supported.");
				break;
		}

	});

	/**
	 * -- JAVASCRIPT
	 */
	var launchJavascriptBuild = function(targets, configuration, targetName){
		// if no target is provided, stop process
		if(!targets){
			grunt.log.writeln("There is not any target");
			return true;
		}

		// get references to possible targets 
		var android = targets.android;
		var ios = targets.ios;
		var web = targets.web;

		// if all targets are excluded, stop process
		if(!android && !ios && !web){
			grunt.log.writeln("All targets are excluded");
			return true;
		}

		// if the build concerns the libs and it is asked to rebuild nuborn
		if(targetName === "libs" && configuration.buildNubornFirst){
			// build nuborn
			buildNubornJS();
		}

		// get grunt config
		var config = grunt.config.data;
		// get the existing closure compiler config, or a new one 
		config["closure-compiler"] = config["closure-compiler"] || {};
		// get a reference to the configuration of closure compiler
		var closure = config["closure-compiler"];
		// create and initialize the default target
		var target = {
			closurePath : "closure"
		};
		// Create array of Closure Targets
		var nubornClosureTargets = [];
		// define a default closure configuration
		var defaultConfiguration = {
			compilation_level : targetName === "app" ? "SIMPLE_OPTIMIZATIONS" : "WHITESPACE_ONLY"
		};
		// create the target options
		target.options = jQueryExtend(true, {}, defaultConfiguration, configuration.options);
		
		// Check if a separate build is needed
		var separate = false;
		if(android){
			separate = separate || needsSeparateBuilds(configuration.android);
		}
		if(ios){
			separate = separate || needsSeparateBuilds(configuration.ios);
		}
		if(web){
			separate = separate || needsSeparateBuilds(configuration.web);
		}

		// sets the output file name
		var output = configuration.output ? configuration.output : "output.min.js"; 

		// if separate builds are needed
		if(separate){
			// build all separately
			if(android){
				closure["nuborn-android"] = buildClosureTarget("android", target, output, configuration);
				nubornClosureTargets.push("closure-compiler:nuborn-android");
			}
			if(ios){
				closure["nuborn-ios"] = buildClosureTarget("ios", target, output, configuration);	
				nubornClosureTargets.push("closure-compiler:nuborn-ios");
			}
			if(web){
				closure["nuborn-web"] = buildClosureTarget("web", target, output, configuration);
				nubornClosureTargets.push("closure-compiler:nuborn-web");
			}
		} else {
			// get the timestamp to avoid potential conflicts
			var suffix = new Date().getTime();
			// create the temp folder
			grunt.file.mkdir("build/closure"+suffix);
			// build one and copy
			closure["nuborn-target"] = buildClosureTarget("closure"+suffix, target, output, configuration);
			nubornClosureTargets.push("closure-compiler:nuborn-target");
		}

		/**
		 * RUN CLOSURE COMPILER TASKS
		 */
		grunt.task.run(nubornClosureTargets);

		/**
		 * COPY REPORTS AND FILES FOR NON SEPARATE BUILDS
		 */
		if(separate){
			if(android){
				grunt.task.run("nuborn-move:"+closure["nuborn-android"].jsOutputFile+".report.txt:closure/reports/android.report.txt");
			}
			if(ios){
				grunt.task.run("nuborn-move:"+closure["nuborn-ios"].jsOutputFile+".report.txt:closure/reports/ios.report.txt");
			}
			if(web){
				grunt.task.run("nuborn-move:"+closure["nuborn-web"].jsOutputFile+".report.txt:closure/reports/web.report.txt");
			}
		} else {
			if(android){
				var androidOutput = configuration.android && configuration.android.output ? configuration.android.output : output;
				grunt.task.run("nuborn-copy:build/closure"+suffix+"/"+output+":build/android/"+androidOutput);
			}
			if(ios){
				var iosOutput = configuration.ios && configuration.ios.output ? configuration.ios.output : output;
				grunt.task.run("nuborn-copy:build/closure"+suffix+"/"+output+":build/ios/"+iosOutput);
			}
			if(web){
				var webOutput = configuration.web && configuration.web.output ? configuration.web.output : output;
				grunt.task.run("nuborn-copy:build/closure"+suffix+"/"+output+":build/web/"+webOutput);
			}

			grunt.task.run("nuborn-copy:build/closure"+suffix+"/"+output+".report.txt:closure/reports/"+output+".report.txt");
			grunt.task.run("nuborn-delete:build/closure"+suffix);
		}

		// Clean configuration
		for(var i = 0, length = nubornClosureTargets.length; i<length; i++){
			var closureTarget = nubornClosureTargets[i];
			delete closure[closureTarget];
		}		
	};

	var needsSeparateBuilds = function(target){
		// if the target is not specified, no need to build it separately
		if(!target){
			return false;
		}
		// if options is specified AND is not empty, needs a separate build
		if(target.options && Object.keys(target.options).length){
			return true;
		}
		// if patterns is specified AND is not empty, needs a separate build
		if(target.patterns && Object.keys(target.patterns).length){
			return true;
		}
		// otherwise do not need a separate build
		return false;
	};

	var buildClosureTarget = function(targetName, parent, output, configuration){
		// Clone the parent target
		var target = jQueryExtend(true, {}, parent);
		// initialize target sources with the common one or a new one
		var targetSources = [].concat(configuration.patterns ? configuration.patterns : []);
		// treat target specific configuration
		if(configuration[targetName]){
			// get the configuration for the current target
			var targetConfiguration = configuration[targetName];
			// extends options with target's options
			jQueryExtend(true, target.options, targetConfiguration.options);
			
			// treat target specific output file
			if(targetConfiguration.output){
				target.jsOutputFile = "build/"+targetName+"/"+targetConfiguration.output;
			} else{
				target.jsOutputFile = "build/"+targetName+"/"+output;
			}

			// add the target sources to the initial sources
			if(targetConfiguration.patterns){
				targetSources = targetSources.concat(targetConfiguration.patterns);
			}

		} else {
			// just set the output file
			target.jsOutputFile = "build/"+targetName+"/"+output;
		}
		// set the js property of closure with target sources
		target.js = targetSources;
		// return the target
		return target;
	};

	var buildNubornJS = function(){
		// get grunt configuration
		var config = grunt.config.data;
		// get existing closure configuration or a new one
		config["closure-compiler"] = config["closure-compiler"] || {};
		// set a reference to the closure configuration
		var closure = config["closure-compiler"];
		// create a new target for closure compiler
		var nuborn = {};
		closure["nuborn-nuborn"] = nuborn;
		// path to closure compiler
		nuborn.closurePath = "closure";
		// build all except nuborn.js itself
		nuborn.js = [
			"libs/Nuborn/**/*.js",
			"!libs/Nuborn/nuborn.js"
		];
		// build nuborn.js
		nuborn.jsOutputFile = "libs/Nuborn/nuborn.js";
		// set closure compiler options
		nuborn.options = {
			compilation_level: "SIMPLE_OPTIMIZATIONS"
		};
		// run the task
		grunt.task.run("closure-compiler:nuborn-nuborn");
		// move the report file
		grunt.task.run("nuborn-move:libs/Nuborn/nuborn.js.report.txt:closure/reports/nuborn.report.txt");
	};

	/**
	 * -- CSS
	 */
	grunt.launchCSSBuild = function(targets, configuration, targetName){
		// if no target is provided, stop process
		if(!targets){
			grunt.log.writeln("There is not any target");
			return true;
		}

		// get references to possible targets 
		var android = targets.android;
		var ios = targets.ios;
		var web = targets.web;

		// if all targets are excluded, stop process
		if(!android && !ios && !web){
			grunt.log.writeln("All targets are excluded");
			return true;
		}

		// if the build concerns the libs and it is asked to rebuild nuborn
		if(targetName === "libs" && configuration.buildNubornFirst){
			// build nuborn
			buildNubornCSS();
		}
		// get grunt config
		var config = grunt.config.data;
		// get the existing sass config, or a new one 
		config.sass = config.sass || {};
		// get a reference to the configuration of sass
		var sass = config.sass;
		// create and initialize the default target
		var target = {};
		// Create array of Sass Targets
		var nubornSassTargets = [];
		// define a default sass configuration
		var defaultConfiguration = {
			style: "compressed",
			noCache: true
		};
		// create the target options
		target.options = jQueryExtend(true, {}, defaultConfiguration, configuration.options);
		
		// Check if a separate build is needed
		var separate = false;
		if(android){
			separate = separate || needsSeparateBuilds(configuration.android);
		}
		if(ios){
			separate = separate || needsSeparateBuilds(configuration.ios);
		}
		if(web){
			separate = separate || needsSeparateBuilds(configuration.web);
		}

		// sets the output file name
		var output = configuration.output ? configuration.output : "output.min.css"; 

		// if separate builds are needed
		if(separate){
			// build all separately
			if(android){
				sass["nuborn-android"] = buildSassTarget("android", target, output, configuration);
				nubornSassTargets.push("sass:nuborn-android");
			}
			if(ios){
				sass["nuborn-ios"] = buildSassTarget("ios", target, output, configuration);	
				nubornSassTargets.push("sass:nuborn-ios");
			}
			if(web){
				sass["nuborn-web"] = buildSassTarget("web", target, output, configuration);
				nubornSassTargets.push("sass:nuborn-web");
			}
		} else {
			// get the timestamp to avoid potential conflicts
			var suffix = new Date().getTime();
			// create the temp folder
			grunt.file.mkdir("build/sass"+suffix);
			// build one and copy
			sass["nuborn-target"] = buildSassTarget("sass"+suffix, target, output, configuration);
			nubornSassTargets.push("sass:nuborn-target");
		}

		/**
		 * RUN SASS TASKS
		 */
		grunt.task.run(nubornSassTargets);

		/**
		 * COPY FILES IF NOT SEPARATE
		 */
		if(!separate){
			if(android){
				var androidOutput = configuration.android && configuration.android.output ? configuration.android.output : output;
				grunt.task.run("nuborn-copy:build/sass"+suffix+"/"+output+":build/android/"+androidOutput);
			}
			if(ios){
				var iosOutput = configuration.ios && configuration.ios.output ? configuration.ios.output : output;
				grunt.task.run("nuborn-copy:build/sass"+suffix+"/"+output+":build/ios/"+iosOutput);
			}
			if(web){
				var webOutput = configuration.web && configuration.web.output ? configuration.web.output : output;
				grunt.task.run("nuborn-copy:build/sass"+suffix+"/"+output+":build/web/"+webOutput);
			}

			grunt.task.run("nuborn-delete:build/sass"+suffix);
		}

		// Clean configuration
		/*for(var i = 0, length = nubornSassTargets.length; i<length; i++){
			var sassTarget = nubornSassTargets[i];
			delete sass[sassTarget];
		}		*/
	};

	var buildSassTarget = function(targetName, parent, output, configuration){
		// Clone the parent target
		var target = jQueryExtend(true, {}, parent);
		// initialize target sources with the common one or a new one
		var targetSources = [].concat(configuration.patterns ? configuration.patterns : []);
		var targetOutput = "build/"+targetName+"/"+output;
		// treat target specific configuration
		if(configuration[targetName]){
			// get the configuration for the current target
			var targetConfiguration = configuration[targetName];
			// extends options with target's options
			jQueryExtend(true, target.options, targetConfiguration.options);
			
			// treat target specific output file
			if(targetConfiguration.output){
				targetOutput = "build/"+targetName+"/"+targetConfiguration.output;
			}

			// add the target sources to the initial sources
			if(targetConfiguration.patterns){
				targetSources = targetSources.concat(targetConfiguration.patterns);
			}
		}

		// set the files property of sass with target sources
		target.files = {};
		target.files[targetOutput] = targetSources;
		// return the target
		return target;
	};

	var buildNubornCSS = function(){
		// get grunt configuration
		var config = grunt.config.data;
		// get existing sass configuration or a new one
		config.sass = config.sass || {};
		// set a reference to the sass configuration
		var sass = config.sass;
		// create a new target for sass
		var nuborn = {};
		sass["nuborn-nuborn"] = nuborn;
		// files to build with sass
		nuborn.files = {
			"libs/Nuborn/nuborn.css": [
				"libs/Nuborn/sass/mixins.scss",
				"libs/Nuborn/sass/classes.scss",
				"libs/Nuborn/**/*.scss"
			]
		};
		// set sass options
		nuborn.options = {
			style: "compressed",
			noCache: true
		};
		// run the task
		grunt.task.run("sass:nuborn-nuborn");
	};

	/**
	 * -- HTML
	 */
	grunt.launchHTMLBuild = function(targets, configuration, targetName){
		// if no target is provided, stop process
		if(!targets){
			grunt.log.writeln("There is not any target");
			return true;
		}

		// get references to possible targets 
		var android = targets.android;
		var ios = targets.ios;
		var web = targets.web;

		var androidConfiguration = configuration.android || {};
		var iosConfiguration = configuration.ios || {};
		var webConfiguration = configuration.web || {};

		// if all targets are excluded, stop process
		if(!android && !ios && !web){
			grunt.log.writeln("All targets are excluded");
			return true;
		}

		var output = configuration.output ? addSlashToPath(configuration.output) : "";
		var androidOutput =  "build/android/"+(androidConfiguration.output ? addSlashToPath(androidConfiguration.output) : output);
		var iosOutput =  "build/ios/"+(iosConfiguration.output ? addSlashToPath(iosConfiguration.output) : output);
		var webOutput =  "build/web/"+(webConfiguration.output ? addSlashToPath(webConfiguration.output) : output);

		var array = grunt.file.expand(configuration.patterns);
		for(var i = 0, length = array.length; i < length; i++){
			var file = array[i];
			var filename = getName(file);
			android && grunt.file.copy(file, androidOutput+filename);
			ios && grunt.file.copy(file, iosOutput+filename);
			web && grunt.file.copy(file, webOutput+filename);
		}

		var templates = grunt.file.expand("src/**/"+configuration.templatesFolderName+"/*.html");
		for(var i = 0, length = templates.length; i < length; i++){
			var file = templates[i];
			var filename = getName(file);
			var path = file.replace(filename, "");
			var module = getParentName(path);
			android && grunt.file.copy(file, androidOutput+configuration.templatesFolderName+"/"+module+"/"+filename);
			ios && grunt.file.copy(file, iosOutput+configuration.templatesFolderName+"/"+module+"/"+filename);
			web && grunt.file.copy(file, webOutput+configuration.templatesFolderName+"/"+module+"/"+filename);
		}
	};

	/**
	 * Simple add a slash to a dir if there is not
	 */
	var addSlashToPath = function(path){
		var dir = path
		if(dir.charAt(dir.length-1) !== "/"){
			dir = dir.substring(0, dir.length-1);
		}
		return dir;
	};

	/**
	 * Get the name of the parent directory ofthe given file (can be a directory)
	 */
	var getParentName = function(file){
		var index = 0;
		var parent = file;
		if(grunt.file.isDir(parent)){
			if(parent.charAt(parent.length-1) === "/"){
				parent = parent.substring(0, parent.length-1);
			}
		}
		index = Math.max(parent.lastIndexOf("/"), 0);
		parent = parent.substring(0, index);
		index = parent.lastIndexOf("/");
		parent = parent.substring(index ===  -1 ? 0 : index+1);
		return parent;
	};

	/**
	 * Get the name of the parent directory ofthe given file (can be a directory)
	 */
	var getName = function(file){
		var index = 0;
		var parent = file;
		if(grunt.file.isDir(parent)){
			if(parent.charAt(parent.length-1) === "/"){
				parent = parent.substring(0, parent.length-1);
			}
		}
		index = Math.max(parent.lastIndexOf("/"), 0);
		parent = parent.substring(index+1);
		return parent;
	};

	/**
	 * The jQuery Extend method too easily extend configurations
	 */
	 var jQueryExtend = function() {
		var src, copyIsArray, copy, name, options, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && typeof target !== 'function' ) {
			target = {};
		}

		// extend jQuery itself if only one argument is passed
		if ( length === i ) {
			target = this;
			--i;
		}

		for ( ; i < length; i++ ) {
			// Only deal with non-null/undefined values
			if ( (options = arguments[ i ]) != null ) {
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( (copyIsArray = Array.isArray(copy)) || (typeof copy === 'object') ) ) {
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && Array.isArray(src) ? src : [];

						} else {
							clone = src && (!Array.isArray(src) && typeof src === 'object') ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQueryExtend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	grunt.registerTask("nuborn-copy", "Copy a file", function(source, destination){
		grunt.file.copy(source, destination);
	});

	grunt.registerTask("nuborn-delete", "Delete a file",  function(file){
		grunt.file.delete(file);
	});

	grunt.registerTask("nuborn-move", "Move a file",  function(source, destination){
		grunt.file.copy(source, destination);
		grunt.file.delete(source);
	});
};
