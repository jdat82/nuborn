/*
 * grunt-nuborn
 * https://github.com/jrob/grunt-nuborn
 *
 * Copyright (c) 2013 Jim Robs & Jean Dat
 * Licensed under the MIT license.
 */

'use strict';

module.exports = function(grunt) {

	/**
	 * Loading task dependencies
	 */
	grunt.loadNpmTasks('grunt-contrib-sass');
	grunt.loadNpmTasks('grunt-closure-compiler');
	grunt.loadNpmTasks('grunt-contrib-copy');
	grunt.loadNpmTasks('grunt-contrib-hogan');

	/**
	 * Register task Nuborn
	 */
	grunt.registerMultiTask('nuborn', 'Your task description goes here.', function()
	{
		var validator = require("./BuildValidator");
		validator.process(this);
	});

	/**
	 * -- JAVASCRIPT
	 */
	var launchJavascriptBuild = function(targets, configuration, scope) {
		// if no target is provided, stop process
		if (!targets) {
			grunt.log.writeln("There is not any target");
			return true;
		}

		// get references to possible targets 
		var android = targets.android;
		var ios = targets.ios;
		var web = targets.web;

		// if all targets are excluded, stop process
		if (!android && !ios && !web) {
			grunt.log.writeln("All targets are excluded");
			return true;
		}

		// if the build concerns the libs and it is asked to rebuild nuborn
		if (scope === scope.libs && configuration.buildNubornFirst) {
			// build nuborn
			buildNubornJS();
		}

		// get grunt config
		var config = grunt.config.data;
		// get the existing closure compiler config, or a new one 
		config["closure-compiler"] = config["closure-compiler"] || {};
		// get a reference to the configuration of closure compiler
		var closure = config["closure-compiler"];
		// create and initialize the default target
		var target = {
			closurePath: "closure"
		};
		// Create array of Closure Targets
		var nubornClosureTargets = [];
		// define a default closure configuration
		var defaultConfiguration = {
			compilation_level: scope === scope.app ? "SIMPLE_OPTIMIZATIONS" : "WHITESPACE_ONLY"
		};
		// create the target options
		target.options = jQueryExtend(true, {}, defaultConfiguration, configuration.options);

		// Check if a separate build is needed
		var separate = false;
		if (android) {
			separate = separate || needsSeparateBuilds(configuration.android);
		}
		if (ios) {
			separate = separate || needsSeparateBuilds(configuration.ios);
		}
		if (web) {
			separate = separate || needsSeparateBuilds(configuration.web);
		}

		// sets the output file name
		var output = configuration.output ? configuration.output : "output.min.js";

		// if separate builds are needed
		if (separate) {
			// build all separately
			if (android) {
				closure["nuborn-android"] = buildClosureTarget("android", target, output, configuration);
				nubornClosureTargets.push("closure-compiler:nuborn-android");
			}
			if (ios) {
				closure["nuborn-ios"] = buildClosureTarget("ios", target, output, configuration);
				nubornClosureTargets.push("closure-compiler:nuborn-ios");
			}
			if (web) {
				closure["nuborn-web"] = buildClosureTarget("web", target, output, configuration);
				nubornClosureTargets.push("closure-compiler:nuborn-web");
			}
		} else {
			// get the timestamp to avoid potential conflicts
			var suffix = new Date().getTime();
			// create the temp folder
			grunt.file.mkdir("build" + sep + "closure" + suffix);
			// build one and copy
			closure["nuborn-target"] = buildClosureTarget("closure" + suffix, target, output, configuration);
			nubornClosureTargets.push("closure-compiler:nuborn-target");
		}

		/**
		 * RUN CLOSURE COMPILER TASKS
		 */
		grunt.task.run(nubornClosureTargets);

		/**
		 * COPY REPORTS AND FILES FOR NON SEPARATE BUILDS
		 */
		if (separate) {
			if (android) {
				grunt.task.run("nuborn-move:" + closure["nuborn-android"].jsOutputFile + ".report.txt:closure" + sep + "reports" + sep + "android.report.txt");
			}
			if (ios) {
				grunt.task.run("nuborn-move:" + closure["nuborn-ios"].jsOutputFile + ".report.txt:closure" + sep + "reports" + sep + "ios.report.txt");
			}
			if (web) {
				grunt.task.run("nuborn-move:" + closure["nuborn-web"].jsOutputFile + ".report.txt:closure" + sep + "reports" + sep + "web.report.txt");
			}
		} else {
			if (android) {
				var androidOutput = configuration.android && configuration.android.output ? configuration.android.output : output;
				grunt.task.run("nuborn-copy:build" + sep + "closure" + suffix + sep + output + ":build" + sep + "android" + sep + androidOutput);
			}
			if (ios) {
				var iosOutput = configuration.ios && configuration.ios.output ? configuration.ios.output : output;
				grunt.task.run("nuborn-copy:build" + sep + "closure" + suffix + sep + output + ":build" + sep + "ios" + sep + iosOutput);
			}
			if (web) {
				var webOutput = configuration.web && configuration.web.output ? configuration.web.output : output;
				grunt.task.run("nuborn-copy:build" + sep + "closure" + suffix + sep + output + ":build" + sep + "web" + sep + webOutput);
			}

			grunt.task.run("nuborn-copy:build" + sep + "closure" + suffix + sep + output + ".report.txt:closure" + sep + "reports" + sep + output + ".report.txt");
			grunt.task.run("nuborn-delete:build" + sep + "closure" + suffix);
		}
	};

	var needsSeparateBuilds = function(target) {
		// if the target is not specified, no need to build it separately
		if (!target) {
			return false;
		}
		// if options is specified AND is not empty, needs a separate build
		if (target.options && Object.keys(target.options).length) {
			return true;
		}
		// if patterns is specified AND is not empty, needs a separate build
		if (target.patterns && Object.keys(target.patterns).length) {
			return true;
		}
		// otherwise do not need a separate build
		return false;
	};

	var buildClosureTarget = function(targetName, parent, output, configuration) {
		// Clone the parent target
		var target = jQueryExtend(true, {}, parent);
		// initialize target sources with the common one or a new one
		var targetSources = [].concat(configuration.patterns ? configuration.patterns : []);
		// treat target specific configuration
		if (configuration[targetName]) {
			// get the configuration for the current target
			var targetConfiguration = configuration[targetName];
			// extends options with target's options
			jQueryExtend(true, target.options, targetConfiguration.options);

			// treat target specific output file
			if (targetConfiguration.output) {
				target.jsOutputFile = "build" + sep + targetName + sep + targetConfiguration.output;
			} else {
				target.jsOutputFile = "build" + sep + targetName + sep + output;
			}

			// add the target sources to the initial sources
			if (targetConfiguration.patterns) {
				targetSources = targetSources.concat(targetConfiguration.patterns);
			}

		} else {
			// just set the output file
			target.jsOutputFile = "build" + sep + targetName + sep + output;
		}
		// set the js property of closure with target sources
		target.js = targetSources;
		// return the target
		return target;
	};

	var buildNubornJS = function() {
		// get grunt configuration
		var config = grunt.config.data;
		// get existing closure configuration or a new one
		config["closure-compiler"] = config["closure-compiler"] || {};
		// set a reference to the closure configuration
		var closure = config["closure-compiler"];
		// create a new target for closure compiler
		var nuborn = {};
		closure["nuborn-nuborn"] = nuborn;
		// path to closure compiler
		nuborn.closurePath = "closure";
		// build all except nuborn.js itself
		nuborn.js = [
				scope.libs + sep + "Nuborn" + sep + "**" + sep + "*.js",
				"!libs" + sep + "Nuborn" + sep + "nuborn.js"
		];
		// build nuborn.js
		nuborn.jsOutputFile = scope.libs + sep + "Nuborn" + sep + "nuborn.js";
		// set closure compiler options
		nuborn.options = {
			compilation_level: "SIMPLE_OPTIMIZATIONS"
		};
		// run the task
		grunt.task.run("closure-compiler:nuborn-nuborn");
		// move the report file
		grunt.task.run("nuborn-move:libs" + sep + "Nuborn" + sep + "nuborn.js.report.txt:closure" + sep + "reports" + sep + "nuborn.report.txt");
	};

	/**
	 * -- CSS
	 */
	var launchCSSBuild = function(targets, configuration, scope) {
		// if no target is provided, stop process
		if (!targets) {
			grunt.log.writeln("There is not any target");
			return true;
		}

		// get references to possible targets 
		var android = targets.android;
		var ios = targets.ios;
		var web = targets.web;

		// if all targets are excluded, stop process
		if (!android && !ios && !web) {
			grunt.log.writeln("All targets are excluded");
			return true;
		}

		// if the build concerns the libs and it is asked to rebuild nuborn
		if (scope === scope.libs && configuration.buildNubornFirst) {
			// build nuborn
			buildNubornCSS();
		}
		// get grunt config
		var config = grunt.config.data;
		// get the existing sass config, or a new one 
		config.sass = config.sass || {};
		// get a reference to the configuration of sass
		var sass = config.sass;
		// create and initialize the default target
		var target = {};
		// Create array of Sass Targets
		var nubornSassTargets = [];
		// define a default sass configuration
		var defaultConfiguration = {
			style: "compressed",
			noCache: true
		};
		// create the target options
		target.options = jQueryExtend(true, {}, defaultConfiguration, configuration.options);

		// Check if a separate build is needed
		var separate = false;
		if (android) {
			separate = separate || needsSeparateBuilds(configuration.android);
		}
		if (ios) {
			separate = separate || needsSeparateBuilds(configuration.ios);
		}
		if (web) {
			separate = separate || needsSeparateBuilds(configuration.web);
		}

		// sets the output file name
		var output = configuration.output ? configuration.output : "output.min.css";

		// if separate builds are needed
		if (separate) {
			// build all separately
			if (android) {
				sass["nuborn-android"] = buildSassTarget("android", target, output, configuration);
				nubornSassTargets.push("sass:nuborn-android");
			}
			if (ios) {
				sass["nuborn-ios"] = buildSassTarget("ios", target, output, configuration);
				nubornSassTargets.push("sass:nuborn-ios");
			}
			if (web) {
				sass["nuborn-web"] = buildSassTarget("web", target, output, configuration);
				nubornSassTargets.push("sass:nuborn-web");
			}
		} else {
			// get the timestamp to avoid potential conflicts
			var suffix = new Date().getTime();
			// create the temp folder
			grunt.file.mkdir("build" + sep + "sass" + suffix);
			// build one and copy
			sass["nuborn-target"] = buildSassTarget("sass" + suffix, target, output, configuration);
			nubornSassTargets.push("sass:nuborn-target");
		}

		/**
		 * RUN SASS TASKS
		 */
		grunt.task.run(nubornSassTargets);

		/**
		 * COPY FILES IF NOT SEPARATE
		 */
		if (!separate) {
			if (android) {
				var androidOutput = configuration.android && configuration.android.output ? configuration.android.output : output;
				grunt.task.run("nuborn-copy:build" + sep + "sass" + suffix + sep + output + ":build" + sep + "android" + sep + androidOutput);
			}
			if (ios) {
				var iosOutput = configuration.ios && configuration.ios.output ? configuration.ios.output : output;
				grunt.task.run("nuborn-copy:build" + sep + "sass" + suffix + sep + output + ":build" + sep + "ios" + sep + iosOutput);
			}
			if (web) {
				var webOutput = configuration.web && configuration.web.output ? configuration.web.output : output;
				grunt.task.run("nuborn-copy:build" + sep + "sass" + suffix + sep + output + ":build" + sep + "web" + sep + webOutput);
			}

			grunt.task.run("nuborn-delete:build" + sep + "sass" + suffix);
		}
	};

	var buildSassTarget = function(targetName, parent, output, configuration) {
		// Clone the parent target
		var target = jQueryExtend(true, {}, parent);
		// initialize target sources with the common one or a new one
		var targetSources = [].concat(configuration.patterns ? configuration.patterns : []);
		var targetOutput = "build" + sep + targetName + sep + output;
		// treat target specific configuration
		if (configuration[targetName]) {
			// get the configuration for the current target
			var targetConfiguration = configuration[targetName];
			// extends options with target's options
			jQueryExtend(true, target.options, targetConfiguration.options);

			// treat target specific output file
			if (targetConfiguration.output) {
				targetOutput = "build" + sep + targetName + sep + targetConfiguration.output;
			}

			// add the target sources to the initial sources
			if (targetConfiguration.patterns) {
				targetSources = targetSources.concat(targetConfiguration.patterns);
			}
		}

		// set the files property of sass with target sources
		target.files = {};
		target.files[targetOutput] = targetSources;
		// return the target
		return target;
	};

	var buildNubornCSS = function() {
		// get grunt configuration
		var config = grunt.config.data;
		// get existing sass configuration or a new one
		config.sass = config.sass || {};
		// set a reference to the sass configuration
		var sass = config.sass;
		// create a new target for sass
		var nuborn = {};
		sass["nuborn-nuborn"] = nuborn;
		// files to build with sass
		var output = scope.libs + sep + "Nuborn" + sep + "nuborn.css";
		nuborn.files = {
			output: [
					scope.libs + sep + "Nuborn" + sep + "sass" + sep + "mixins.scss",
					scope.libs + sep + "Nuborn" + sep + "sass" + sep + "classes.scss",
					scope.libs + sep + "Nuborn" + sep + "**" + sep + "*.scss"
			]
		};
		// set sass options
		nuborn.options = {
			style: "compressed",
			noCache: true
		};
		// run the task
		grunt.task.run("sass:nuborn-nuborn");
	};

	/**
	 * -- TEMPLATES
	 */
	var launchTemplatesBuild = function(targets, configuration, scope) {
		// if no target is provided, stop process
		if (!targets) {
			grunt.log.writeln("There is not any target");
			return true;
		}

		// get references to possible targets 
		var android = targets.android;
		var ios = targets.ios;
		var web = targets.web;

		// if all targets are excluded, stop process
		if (!android && !ios && !web) {
			grunt.log.writeln("All targets are excluded");
			return true;
		}

		var config = grunt.config.data;
		// get the existing hogan config, or a new one 
		config["hogan"] = config["hogan"] || {};
		// get a reference to the configuration of hogan
		var hogan = config["hogan"];
		// create and initialize the default target
		var target = {};
		// Create array of Hogan Targets
		var nubornHoganTargets = [];
		// define a default hogan configuration
		var defaultConfiguration = {
			namespace: "Templates",
			prettify: true,
			defaultName: function(fileName) {
				var name = nodePath.basename(fileName, nodePath.extname(fileName));
				var module = nodePath.basename(nodePath.dirname(nodePath.dirname(fileName)));
				return module + "_" + name;
			}
		};
		// create the target options
		target.options = jQueryExtend(true, {}, defaultConfiguration, configuration.options);
		// Create the sources 
		var targetSources = [].concat(configuration.patterns ? configuration.patterns : []);
		if (!targetSources.length) {
			grunt.log.writeln("Patterns directive is empty.");
			return false;
		}
		// initialize files directive
		var key = "src" + sep + "nuborn-hogan.js";
		target.files = {
			key: targetSources
		};
		// register the target to the task
		hogan["nuborn-target"] = target;
		// run the hogan task
		grunt.task.run("hogan:nuborn-target");
	};

	/**
	 * -- UTILS
	 */

	/**
	 * Simple add a slash to a dir if there is not
	 */
	var addSeparatorToPath = function(path) {
		var dir = path
		if (dir.charAt(dir.length - 1) !== sep) {
			dir = dir + sep;
		}
		return dir;
	};

	/**
	 * The jQuery Extend method too easily extend configurations
	 */
	var jQueryExtend = function() {
		var src, copyIsArray, copy, name, options, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if (typeof target === "boolean") {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if (typeof target !== "object" && typeof target !== 'function') {
			target = {};
		}

		// extend jQuery itself if only one argument is passed
		if (length === i) {
			target = this;
			--i;
		}

		for (; i < length; i++) {
			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {
				// Extend the base object
				for (name in options) {
					src = target[name];
					copy = options[name];

					// Prevent never-ending loop
					if (target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep && copy && ((copyIsArray = Array.isArray(copy)) || (typeof copy === 'object'))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && Array.isArray(src) ? src : [];

						} else {
							clone = src && (!Array.isArray(src) && typeof src === 'object') ? src : {};
						}

						// Never move original objects, clone them
						target[name] = jQueryExtend(deep, clone, copy);

						// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	/**
	 * -- An utility function that sorts JavaScript files acording to their dependencies
	 * -- @provide & @require
	 */
	var sortFilesAccordingToDependencies = function(patterns) {
		// Get all non sorted sources 
		var sources = grunt.file.expand(patterns);
		// Create the compiled object and array
		var compiled = {};
		var compiledArray = [];
		// Create all requires and provide arrays
		var allRequires = [];
		var allProvides = [];
		// Loop on all sources to find dependences
		for (var i = 0, sourcesLength = sources.length; i < sourcesLength; i++) {
			// get the current source
			var source = sources[i];
			// Read the content of the source
			var content = grunt.file.read(source);
			// Get all documentation block comments
			var comments = content.match(/\/\*\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\//g) || [];

			// Create requires and provides arrays
			var requires = [];
			var provides = [];
			// Loop on the comments to get the requires and provides
			for (var j = 0, commentsLength = comments.length; j < commentsLength; j++) {
				var comment = comments[i];
				requires = requires.concat(comment.match(/(@require).*/g) || []);
				provides = provides.concat(comment.match(/(@provide).*/g) || []);
			}

			// Find all lines containing @provide
			//var provides = content.match(/(@provide).*/g) || [];
			for (var j = 0, providesLength = provides.length; j < providesLength; j++) {
				// get the value for the @provide annotation
				var provide = provides[j].replace("@provide", "").trim();
				// if the provide already exists, stop the task 
				if (allProvides.indexOf(provide) !== -1) {
					grunt.fail.fatal("Multiple Provide : " + provide + " !", 3);
					return false;
				}
				// save the value in the allProvides array
				allProvides.push(provide);
				// replace the current value in the array
				provides[j] = provide;
			}

			// Find all lines containing @require
			var requires = content.match(/(@require).*/g) || [];
			for (var j = 0, requiresLength = requires.length; j < requiresLength; j++) {
				// get the value for the @require annotation
				var require = requires[j].replace("@require", "").trim();
				// replace the current value in the array
				requires[j] = require;
				// save the value in th allRequires array
				if (allRequires.indexOf(require) === -1) {
					allRequires.push(require);
				}
			}

			// save information for the source into a dictionary object
			var compile = {
				source: source,
				requires: requires,
				provides: provides
			};

			// save the compiled object to the compile Array
			compiledArray.push(compile);

			// save the object into the compiled dictionnary with the provides as keys
			for (var j = 0, providesLength = provides.length; j < providesLength; j++) {
				compiled[provides[j]] = compile;
			}
		}

		// Loop on allRequires to check if all requires has a corresponding provide
		for (var i = 0, length = allRequires.length; i < length; i++) {
			var require = allRequires[i];
			if (allProvides.indexOf(require) === -1) {
				grunt.fail.warn("Missing provider : " + require + " is not provided !", 3);
				return false;
			}
		}

		// create recursive method to list all requires of a source
		var recursiveListOfRequires = function(_object, _compiled, _listOfRequires) {
			for (var i = 0, length = _object.requires.length; i < length; i++) {
				var require = _object.requires[i];
				if (_listOfRequires.indexOf(require) === -1) {
					_listOfRequires.push(require);
					recursiveListOfRequires(_compiled[require], _compiled, _listOfRequires);
				}
			}
		}

		// loop on compiled sources to get a complete list of requires including parents requires
		for (var i = 0, length = compiledArray.length; i < length; i++) {
			// get the compile object
			var compile = compiledArray[i];
			// create an array for the full list of requires
			var listOfRequires = [];
			// populate the list with the recursive method
			recursiveListOfRequires(compile, compiled, listOfRequires);
			// loop on provides of the object to find potential cyclic dependencies and prevent infinite loops
			for (var j = 0, l = compile.provides.length; j < l; j++) {
				// get the current provide
				var provide = compile.provides[j];
				// if the full list of requires contains the provide stop the task
				if (listOfRequires.indexOf(provide) !== -1) {
					grunt.fail.fatal("Error : " + compile.source + " raised cyclic dependencies !");
					return false;
				}
			}
			// replace the requires array of the compile object with the full list
			compile.requires = listOfRequires;
		}

		// Sort the compiled array according to dependencies
		compiledArray.sort(function(a, b) {
			// if a requires a provide of b return 1
			for (var i = 0, length = a.requires.length; i < length; i++) {
				if (b.provides.indexOf(a.requires[i]) > -1) {
					return 1;
				}
			}
			// if b requires a provide of a return -1
			for (var i = 0, length = b.requires.length; i < length; i++) {
				if (a.provides.indexOf(b.requires[i]) > -1) {
					return -1;
				}
			}
			// else return 0
			return 0;

		});

		// create the results array containing sorted files
		var results = [];
		// loop on the compiledArray and save sources into result 
		for (var i = 0, length = compiledArray.length; i < length; i++) {
			results.push(compiledArray[i].source);
		}
		// return the results array
		return results;
	};

	grunt.registerTask("nuborn-copy", "Copy a file", function(source, destination) {
		grunt.file.copy(source, destination);
	});

	grunt.registerTask("nuborn-delete", "Delete a file", function(file) {
		grunt.file.delete(file);
	});

	grunt.registerTask("nuborn-move", "Move a file", function(source, destination) {
		grunt.file.copy(source, destination);
		grunt.file.delete(source);
	});
};