/*
 * grunt-nuborn
 * https://github.com/jrob/grunt-nuborn
 *
 * Copyright (c) 2013 Jim Robs & Jean Dat
 * Licensed under the MIT license.
 */

'use strict';

var BuildValidator = require("validator/BuildValidator");

module.exports = function(grunt) {

	/**
	 * Loading task dependencies
	 */
	grunt.loadNpmTasks('grunt-contrib-sass');
	grunt.loadNpmTasks('grunt-closure-compiler');
	grunt.loadNpmTasks('grunt-contrib-copy');
	grunt.loadNpmTasks('grunt-contrib-hogan');

	/**
	 * Register task Nuborn
	 */
	grunt.registerMultiTask('nuborn', 'Your task description goes here.', function()
	{
		var validator = new BuildValidator();
		validator.process(this);
	});

	/**
	 * -- JAVASCRIPT
	 */
	var launchJavascriptBuild = function(targets, configuration, scope) {
		// if no target is provided, stop process
		if (!targets) {
			grunt.log.writeln("There is not any target");
			return true;
		}

		// get references to possible targets 
		var android = targets.android;
		var ios = targets.ios;
		var web = targets.web;

		// if all targets are excluded, stop process
		if (!android && !ios && !web) {
			grunt.log.writeln("All targets are excluded");
			return true;
		}

		// if the build concerns the libs and it is asked to rebuild nuborn
		if (scope === scope.libs && configuration.buildNubornFirst) {
			// build nuborn
			buildNubornJS();
		}

		// get grunt config
		var config = grunt.config.data;
		// get the existing closure compiler config, or a new one 
		config["closure-compiler"] = config["closure-compiler"] || {};
		// get a reference to the configuration of closure compiler
		var closure = config["closure-compiler"];
		// create and initialize the default target
		var target = {
			closurePath: "closure"
		};
		// Create array of Closure Targets
		var nubornClosureTargets = [];
		// define a default closure configuration
		var defaultConfiguration = {
			compilation_level: scope === scope.app ? "SIMPLE_OPTIMIZATIONS" : "WHITESPACE_ONLY"
		};
		// create the target options
		target.options = jQueryExtend(true, {}, defaultConfiguration, configuration.options);

		// Check if a separate build is needed
		var separate = false;
		if (android) {
			separate = separate || needsSeparateBuilds(configuration.android);
		}
		if (ios) {
			separate = separate || needsSeparateBuilds(configuration.ios);
		}
		if (web) {
			separate = separate || needsSeparateBuilds(configuration.web);
		}

		// sets the output file name
		var output = configuration.output ? configuration.output : "output.min.js";

		// if separate builds are needed
		if (separate) {
			// build all separately
			if (android) {
				closure["nuborn-android"] = buildClosureTarget("android", target, output, configuration);
				nubornClosureTargets.push("closure-compiler:nuborn-android");
			}
			if (ios) {
				closure["nuborn-ios"] = buildClosureTarget("ios", target, output, configuration);
				nubornClosureTargets.push("closure-compiler:nuborn-ios");
			}
			if (web) {
				closure["nuborn-web"] = buildClosureTarget("web", target, output, configuration);
				nubornClosureTargets.push("closure-compiler:nuborn-web");
			}
		} else {
			// get the timestamp to avoid potential conflicts
			var suffix = new Date().getTime();
			// create the temp folder
			grunt.file.mkdir("build" + sep + "closure" + suffix);
			// build one and copy
			closure["nuborn-target"] = buildClosureTarget("closure" + suffix, target, output, configuration);
			nubornClosureTargets.push("closure-compiler:nuborn-target");
		}

		/**
		 * RUN CLOSURE COMPILER TASKS
		 */
		grunt.task.run(nubornClosureTargets);

		/**
		 * COPY REPORTS AND FILES FOR NON SEPARATE BUILDS
		 */
		if (separate) {
			if (android) {
				grunt.task.run("nuborn-move:" + closure["nuborn-android"].jsOutputFile + ".report.txt:closure" + sep + "reports" + sep + "android.report.txt");
			}
			if (ios) {
				grunt.task.run("nuborn-move:" + closure["nuborn-ios"].jsOutputFile + ".report.txt:closure" + sep + "reports" + sep + "ios.report.txt");
			}
			if (web) {
				grunt.task.run("nuborn-move:" + closure["nuborn-web"].jsOutputFile + ".report.txt:closure" + sep + "reports" + sep + "web.report.txt");
			}
		} else {
			if (android) {
				var androidOutput = configuration.android && configuration.android.output ? configuration.android.output : output;
				grunt.task.run("nuborn-copy:build" + sep + "closure" + suffix + sep + output + ":build" + sep + "android" + sep + androidOutput);
			}
			if (ios) {
				var iosOutput = configuration.ios && configuration.ios.output ? configuration.ios.output : output;
				grunt.task.run("nuborn-copy:build" + sep + "closure" + suffix + sep + output + ":build" + sep + "ios" + sep + iosOutput);
			}
			if (web) {
				var webOutput = configuration.web && configuration.web.output ? configuration.web.output : output;
				grunt.task.run("nuborn-copy:build" + sep + "closure" + suffix + sep + output + ":build" + sep + "web" + sep + webOutput);
			}

			grunt.task.run("nuborn-copy:build" + sep + "closure" + suffix + sep + output + ".report.txt:closure" + sep + "reports" + sep + output + ".report.txt");
			grunt.task.run("nuborn-delete:build" + sep + "closure" + suffix);
		}
	};

	var needsSeparateBuilds = function(target) {
		// if the target is not specified, no need to build it separately
		if (!target) {
			return false;
		}
		// if options is specified AND is not empty, needs a separate build
		if (target.options && Object.keys(target.options).length) {
			return true;
		}
		// if patterns is specified AND is not empty, needs a separate build
		if (target.patterns && Object.keys(target.patterns).length) {
			return true;
		}
		// otherwise do not need a separate build
		return false;
	};

	var buildClosureTarget = function(targetName, parent, output, configuration) {
		// Clone the parent target
		var target = jQueryExtend(true, {}, parent);
		// initialize target sources with the common one or a new one
		var targetSources = [].concat(configuration.patterns ? configuration.patterns : []);
		// treat target specific configuration
		if (configuration[targetName]) {
			// get the configuration for the current target
			var targetConfiguration = configuration[targetName];
			// extends options with target's options
			jQueryExtend(true, target.options, targetConfiguration.options);

			// treat target specific output file
			if (targetConfiguration.output) {
				target.jsOutputFile = "build" + sep + targetName + sep + targetConfiguration.output;
			} else {
				target.jsOutputFile = "build" + sep + targetName + sep + output;
			}

			// add the target sources to the initial sources
			if (targetConfiguration.patterns) {
				targetSources = targetSources.concat(targetConfiguration.patterns);
			}

		} else {
			// just set the output file
			target.jsOutputFile = "build" + sep + targetName + sep + output;
		}
		// set the js property of closure with target sources
		target.js = targetSources;
		// return the target
		return target;
	};

	var buildNubornJS = function() {
		// get grunt configuration
		var config = grunt.config.data;
		// get existing closure configuration or a new one
		config["closure-compiler"] = config["closure-compiler"] || {};
		// set a reference to the closure configuration
		var closure = config["closure-compiler"];
		// create a new target for closure compiler
		var nuborn = {};
		closure["nuborn-nuborn"] = nuborn;
		// path to closure compiler
		nuborn.closurePath = "closure";
		// build all except nuborn.js itself
		nuborn.js = [
				scope.libs + sep + "Nuborn" + sep + "**" + sep + "*.js",
				"!libs" + sep + "Nuborn" + sep + "nuborn.js"
		];
		// build nuborn.js
		nuborn.jsOutputFile = scope.libs + sep + "Nuborn" + sep + "nuborn.js";
		// set closure compiler options
		nuborn.options = {
			compilation_level: "SIMPLE_OPTIMIZATIONS"
		};
		// run the task
		grunt.task.run("closure-compiler:nuborn-nuborn");
		// move the report file
		grunt.task.run("nuborn-move:libs" + sep + "Nuborn" + sep + "nuborn.js.report.txt:closure" + sep + "reports" + sep + "nuborn.report.txt");
	};

	

	/**
	 * -- TEMPLATES
	 */
	var launchTemplatesBuild = function(targets, configuration, scope) {
		// if no target is provided, stop process
		if (!targets) {
			grunt.log.writeln("There is not any target");
			return true;
		}

		// get references to possible targets 
		var android = targets.android;
		var ios = targets.ios;
		var web = targets.web;

		// if all targets are excluded, stop process
		if (!android && !ios && !web) {
			grunt.log.writeln("All targets are excluded");
			return true;
		}

		var config = grunt.config.data;
		// get the existing hogan config, or a new one 
		config["hogan"] = config["hogan"] || {};
		// get a reference to the configuration of hogan
		var hogan = config["hogan"];
		// create and initialize the default target
		var target = {};
		// Create array of Hogan Targets
		var nubornHoganTargets = [];
		// define a default hogan configuration
		var defaultConfiguration = {
			namespace: "Templates",
			prettify: true,
			defaultName: function(fileName) {
				var name = nodePath.basename(fileName, nodePath.extname(fileName));
				var module = nodePath.basename(nodePath.dirname(nodePath.dirname(fileName)));
				return module + "_" + name;
			}
		};
		// create the target options
		target.options = jQueryExtend(true, {}, defaultConfiguration, configuration.options);
		// Create the sources 
		var targetSources = [].concat(configuration.patterns ? configuration.patterns : []);
		if (!targetSources.length) {
			grunt.log.writeln("Patterns directive is empty.");
			return false;
		}
		// initialize files directive
		var key = "src" + sep + "nuborn-hogan.js";
		target.files = {
			key: targetSources
		};
		// register the target to the task
		hogan["nuborn-target"] = target;
		// run the hogan task
		grunt.task.run("hogan:nuborn-target");
	};

	grunt.registerTask("nuborn-copy", "Copy a file", function(source, destination) {
		grunt.file.copy(source, destination);
	});

	grunt.registerTask("nuborn-delete", "Delete a file", function(file) {
		grunt.file.delete(file);
	});

	grunt.registerTask("nuborn-move", "Move a file", function(source, destination) {
		grunt.file.copy(source, destination);
		grunt.file.delete(source);
	});
};