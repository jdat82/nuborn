/*
 * grunt-nuborn
 * https://github.com/jrob/grunt-nuborn
 *
 * Copyright (c) 2013 Jim Robs
 * Licensed under the MIT license.
 */

'use strict';

module.exports = function(grunt) {

	var nodePath = require("path");
	var sep = nodePath.sep;
	/**
	 * Loading task dependencies
	 */
	grunt.loadNpmTasks('grunt-contrib-sass');
	grunt.loadNpmTasks('grunt-closure-compiler');
	grunt.loadNpmTasks('grunt-contrib-copy');
	grunt.loadNpmTasks('grunt-contrib-hogan');

	/**
	 * Register task Nuborn
	 */
	grunt.registerMultiTask('nuborn', 'Your task description goes here.', function() {
		var extension = grunt.option("extension");

		if(!extension){
			grunt.log.writeln("No extension option is provided.");
			return;
		}

		var target = grunt.option("libs") ? "libs" : "app";
		switch(extension){
			case "js":
			case "hogan":
				if(this.data.templates && this.data.templates[target]){
					launchTemplatesBuild(this.data.targets, this.data.templates[target], target);
				}
				if(this.data.javascript && this.data.javascript[target]){
					launchJavascriptBuild(this.data.targets, this.data.javascript[target], target);
					grunt.task.run("nuborn-delete:src/nuborn-hogan.js");
				} else {
					grunt.log.writeln("Javascript "+target+" configuration is missing");
				}
				break;

			case "scss":
				if(this.data.css && this.data.css[target]){
					launchCSSBuild(this.data.targets, this.data.css[target], target);
				} else{
					grunt.log.writeln("CSS "+target+" configuration is missing");
				}
				break;

			case "html":
				if(this.data.html && this.data.html[target]){
					launchHTMLBuild(this.data.targets, this.data.html[target], target);
				} else{
					grunt.log.writeln("HTML "+target+" configuration is missing");
				}
				break;

			default:
				grunt.log.writeln("The extension provided is not supported.");
				break;
		}

	});

	/**
	 * -- JAVASCRIPT
	 */
	var launchJavascriptBuild = function(targets, configuration, targetName){
		// if no target is provided, stop process
		if(!targets){
			grunt.log.writeln("There is not any target");
			return true;
		}

		// get references to possible targets 
		var android = targets.android;
		var ios = targets.ios;
		var web = targets.web;

		// if all targets are excluded, stop process
		if(!android && !ios && !web){
			grunt.log.writeln("All targets are excluded");
			return true;
		}

		// if the build concerns the libs and it is asked to rebuild nuborn
		if(targetName === "libs" && configuration.buildNubornFirst){
			// build nuborn
			buildNubornJS();
		}

		// get grunt config
		var config = grunt.config.data;
		// get the existing closure compiler config, or a new one 
		config["closure-compiler"] = config["closure-compiler"] || {};
		// get a reference to the configuration of closure compiler
		var closure = config["closure-compiler"];
		// create and initialize the default target
		var target = {
			closurePath : "closure"
		};
		// Create array of Closure Targets
		var nubornClosureTargets = [];
		// define a default closure configuration
		var defaultConfiguration = {
			compilation_level : targetName === "app" ? "SIMPLE_OPTIMIZATIONS" : "WHITESPACE_ONLY"
		};
		// create the target options
		target.options = jQueryExtend(true, {}, defaultConfiguration, configuration.options);
		
		// Check if a separate build is needed
		var separate = false;
		if(android){
			separate = separate || needsSeparateBuilds(configuration.android);
		}
		if(ios){
			separate = separate || needsSeparateBuilds(configuration.ios);
		}
		if(web){
			separate = separate || needsSeparateBuilds(configuration.web);
		}

		// sets the output file name
		var output = configuration.output ? configuration.output : "output.min.js"; 

		// if separate builds are needed
		if(separate){
			// build all separately
			if(android){
				closure["nuborn-android"] = buildClosureTarget("android", target, output, configuration);
				nubornClosureTargets.push("closure-compiler:nuborn-android");
			}
			if(ios){
				closure["nuborn-ios"] = buildClosureTarget("ios", target, output, configuration);	
				nubornClosureTargets.push("closure-compiler:nuborn-ios");
			}
			if(web){
				closure["nuborn-web"] = buildClosureTarget("web", target, output, configuration);
				nubornClosureTargets.push("closure-compiler:nuborn-web");
			}
		} else {
			// get the timestamp to avoid potential conflicts
			var suffix = new Date().getTime();
			// create the temp folder
			grunt.file.mkdir("build"+sep+"closure"+suffix);
			// build one and copy
			closure["nuborn-target"] = buildClosureTarget("closure"+suffix, target, output, configuration);
			nubornClosureTargets.push("closure-compiler:nuborn-target");
		}

		/**
		 * RUN CLOSURE COMPILER TASKS
		 */
		grunt.task.run(nubornClosureTargets);

		/**
		 * COPY REPORTS AND FILES FOR NON SEPARATE BUILDS
		 */
		if(separate){
			if(android){
				grunt.task.run("nuborn-move:"+closure["nuborn-android"].jsOutputFile+".report.txt:closure"+sep+"reports"+sep+"android.report.txt");
			}
			if(ios){
				grunt.task.run("nuborn-move:"+closure["nuborn-ios"].jsOutputFile+".report.txt:closure"+sep+"reports"+sep+"ios.report.txt");
			}
			if(web){
				grunt.task.run("nuborn-move:"+closure["nuborn-web"].jsOutputFile+".report.txt:closure"+sep+"reports"+sep+"web.report.txt");
			}
		} else {
			if(android){
				var androidOutput = configuration.android && configuration.android.output ? configuration.android.output : output;
				grunt.task.run("nuborn-copy:build"+sep+"closure"+suffix+sep+output+":build"+sep+"android"+sep+androidOutput);
			}
			if(ios){
				var iosOutput = configuration.ios && configuration.ios.output ? configuration.ios.output : output;
				grunt.task.run("nuborn-copy:build"+sep+"closure"+suffix+sep+output+":build"+sep+"ios"+sep+iosOutput);
			}
			if(web){
				var webOutput = configuration.web && configuration.web.output ? configuration.web.output : output;
				grunt.task.run("nuborn-copy:build"+sep+"closure"+suffix+sep+output+":build"+sep+"web"+sep+webOutput);
			}

			grunt.task.run("nuborn-copy:build"+sep+"closure"+suffix+sep+output+".report.txt:closure"+sep+"reports"+sep+output+".report.txt");
			grunt.task.run("nuborn-delete:build"+sep+"closure"+suffix);
		}
	};

	var needsSeparateBuilds = function(target){
		// if the target is not specified, no need to build it separately
		if(!target){
			return false;
		}
		// if options is specified AND is not empty, needs a separate build
		if(target.options && Object.keys(target.options).length){
			return true;
		}
		// if patterns is specified AND is not empty, needs a separate build
		if(target.patterns && Object.keys(target.patterns).length){
			return true;
		}
		// otherwise do not need a separate build
		return false;
	};

	var buildClosureTarget = function(targetName, parent, output, configuration){
		// Clone the parent target
		var target = jQueryExtend(true, {}, parent);
		// initialize target sources with the common one or a new one
		var targetSources = [].concat(configuration.patterns ? configuration.patterns : []);
		// treat target specific configuration
		if(configuration[targetName]){
			// get the configuration for the current target
			var targetConfiguration = configuration[targetName];
			// extends options with target's options
			jQueryExtend(true, target.options, targetConfiguration.options);
			
			// treat target specific output file
			if(targetConfiguration.output){
				target.jsOutputFile = "build"+sep+targetName+sep+targetConfiguration.output;
			} else{
				target.jsOutputFile = "build"+sep+targetName+sep+output;
			}

			// add the target sources to the initial sources
			if(targetConfiguration.patterns){
				targetSources = targetSources.concat(targetConfiguration.patterns);
			}

		} else {
			// just set the output file
			target.jsOutputFile = "build"+sep+targetName+sep+output;
		}
		// set the js property of closure with target sources
		target.js = targetSources;
		// return the target
		return target;
	};

	var buildNubornJS = function(){
		// get grunt configuration
		var config = grunt.config.data;
		// get existing closure configuration or a new one
		config["closure-compiler"] = config["closure-compiler"] || {};
		// set a reference to the closure configuration
		var closure = config["closure-compiler"];
		// create a new target for closure compiler
		var nuborn = {};
		closure["nuborn-nuborn"] = nuborn;
		// path to closure compiler
		nuborn.closurePath = "closure";
		// build all except nuborn.js itself
		nuborn.js = [
			"libs"+sep+"Nuborn"+sep+"**"+sep+"*.js",
			"!libs"+sep+"Nuborn"+sep+"nuborn.js"
		];
		// build nuborn.js
		nuborn.jsOutputFile = "libs"+sep+"Nuborn"+sep+"nuborn.js";
		// set closure compiler options
		nuborn.options = {
			compilation_level: "SIMPLE_OPTIMIZATIONS"
		};
		// run the task
		grunt.task.run("closure-compiler:nuborn-nuborn");
		// move the report file
		grunt.task.run("nuborn-move:libs"+sep+"Nuborn"+sep+"nuborn.js.report.txt:closure"+sep+"reports"+sep+"nuborn.report.txt");
	};

	/**
	 * -- CSS
	 */
	 var launchCSSBuild = function(targets, configuration, targetName){
		// if no target is provided, stop process
		if(!targets){
			grunt.log.writeln("There is not any target");
			return true;
		}

		// get references to possible targets 
		var android = targets.android;
		var ios = targets.ios;
		var web = targets.web;

		// if all targets are excluded, stop process
		if(!android && !ios && !web){
			grunt.log.writeln("All targets are excluded");
			return true;
		}

		// if the build concerns the libs and it is asked to rebuild nuborn
		if(targetName === "libs" && configuration.buildNubornFirst){
			// build nuborn
			buildNubornCSS();
		}
		// get grunt config
		var config = grunt.config.data;
		// get the existing sass config, or a new one 
		config.sass = config.sass || {};
		// get a reference to the configuration of sass
		var sass = config.sass;
		// create and initialize the default target
		var target = {};
		// Create array of Sass Targets
		var nubornSassTargets = [];
		// define a default sass configuration
		var defaultConfiguration = {
			style: "compressed",
			noCache: true
		};
		// create the target options
		target.options = jQueryExtend(true, {}, defaultConfiguration, configuration.options);
		
		// Check if a separate build is needed
		var separate = false;
		if(android){
			separate = separate || needsSeparateBuilds(configuration.android);
		}
		if(ios){
			separate = separate || needsSeparateBuilds(configuration.ios);
		}
		if(web){
			separate = separate || needsSeparateBuilds(configuration.web);
		}

		// sets the output file name
		var output = configuration.output ? configuration.output : "output.min.css"; 

		// if separate builds are needed
		if(separate){
			// build all separately
			if(android){
				sass["nuborn-android"] = buildSassTarget("android", target, output, configuration);
				nubornSassTargets.push("sass:nuborn-android");
			}
			if(ios){
				sass["nuborn-ios"] = buildSassTarget("ios", target, output, configuration);	
				nubornSassTargets.push("sass:nuborn-ios");
			}
			if(web){
				sass["nuborn-web"] = buildSassTarget("web", target, output, configuration);
				nubornSassTargets.push("sass:nuborn-web");
			}
		} else {
			// get the timestamp to avoid potential conflicts
			var suffix = new Date().getTime();
			// create the temp folder
			grunt.file.mkdir("build"+sep+"sass"+suffix);
			// build one and copy
			sass["nuborn-target"] = buildSassTarget("sass"+suffix, target, output, configuration);
			nubornSassTargets.push("sass:nuborn-target");
		}

		/**
		 * RUN SASS TASKS
		 */
		grunt.task.run(nubornSassTargets);

		/**
		 * COPY FILES IF NOT SEPARATE
		 */
		if(!separate){
			if(android){
				var androidOutput = configuration.android && configuration.android.output ? configuration.android.output : output;
				grunt.task.run("nuborn-copy:build"+sep+"sass"+suffix+sep+output+":build"+sep+"android"+sep+androidOutput);
			}
			if(ios){
				var iosOutput = configuration.ios && configuration.ios.output ? configuration.ios.output : output;
				grunt.task.run("nuborn-copy:build"+sep+"sass"+suffix+sep+output+":build"+sep+"ios"+sep+iosOutput);
			}
			if(web){
				var webOutput = configuration.web && configuration.web.output ? configuration.web.output : output;
				grunt.task.run("nuborn-copy:build"+sep+"sass"+suffix+sep+output+":build"+sep+"web"+sep+webOutput);
			}

			grunt.task.run("nuborn-delete:build"+sep+"sass"+suffix);
		}
	};

	var buildSassTarget = function(targetName, parent, output, configuration){
		// Clone the parent target
		var target = jQueryExtend(true, {}, parent);
		// initialize target sources with the common one or a new one
		var targetSources = [].concat(configuration.patterns ? configuration.patterns : []);
		var targetOutput = "build"+sep+targetName+sep+output;
		// treat target specific configuration
		if(configuration[targetName]){
			// get the configuration for the current target
			var targetConfiguration = configuration[targetName];
			// extends options with target's options
			jQueryExtend(true, target.options, targetConfiguration.options);
			
			// treat target specific output file
			if(targetConfiguration.output){
				targetOutput = "build"+sep+targetName+sep+targetConfiguration.output;
			}

			// add the target sources to the initial sources
			if(targetConfiguration.patterns){
				targetSources = targetSources.concat(targetConfiguration.patterns);
			}
		}

		// set the files property of sass with target sources
		target.files = {};
		target.files[targetOutput] = targetSources;
		// return the target
		return target;
	};

	var buildNubornCSS = function(){
		// get grunt configuration
		var config = grunt.config.data;
		// get existing sass configuration or a new one
		config.sass = config.sass || {};
		// set a reference to the sass configuration
		var sass = config.sass;
		// create a new target for sass
		var nuborn = {};
		sass["nuborn-nuborn"] = nuborn;
		// files to build with sass
		var output = "libs"+sep+"Nuborn"+sep+"nuborn.css";
		nuborn.files = {
			output : [
				"libs"+sep+"Nuborn"+sep+"sass"+sep+"mixins.scss",
				"libs"+sep+"Nuborn"+sep+"sass"+sep+"classes.scss",
				"libs"+sep+"Nuborn"+sep+"**"+sep+"*.scss"
			]
		};
		// set sass options
		nuborn.options = {
			style: "compressed",
			noCache: true
		};
		// run the task
		grunt.task.run("sass:nuborn-nuborn");
	};

	/**
	 * -- HTML
	 */
	 var launchHTMLBuild = function(targets, configuration, targetName){
		// if no target is provided, stop process
		if(!targets){
			grunt.log.writeln("There is not any target");
			return true;
		}

		// get references to possible targets 
		var android = targets.android;
		var ios = targets.ios;
		var web = targets.web;

		var androidConfiguration = configuration.android || {};
		var iosConfiguration = configuration.ios || {};
		var webConfiguration = configuration.web || {};

		// if all targets are excluded, stop process
		if(!android && !ios && !web){
			grunt.log.writeln("All targets are excluded");
			return true;
		}

		// default output if empty string (target project root)
		var output = "";
		// if an output is specified, use it
		if(configuration.output){
			var out = configuration.output;
			if(nodePath.isFile(out)){
				out = nodePath.dirname(out);
			}
			output = addSeparatorToPath(out);
		}
		// create ouputs for all targets
		var androidOutput =  "build"+sep+"android"+sep+(androidConfiguration.output ? addSeparatorToPath(androidConfiguration.output) : output);
		var iosOutput =  "build"+sep+"ios"+sep+(iosConfiguration.output ? addSeparatorToPath(iosConfiguration.output) : output);
		var webOutput =  "build"+sep+"web"+sep+(webConfiguration.output ? addSeparatorToPath(webConfiguration.output) : output);

		if(!configuration.patterns.length){
			grunt.log.writeln("Missing configuration.patterns directive.");
			return false;
		}
		// list all files into patterns directive and copy them to targets
		var array = grunt.file.expand(configuration.patterns);
		for(var i = 0, length = array.length; i < length; i++){
			var file = array[i];
			var filename = nodePath.basename(file);
			android && grunt.file.copy(file, androidOutput+filename);
			ios && grunt.file.copy(file, iosOutput+filename);
			web && grunt.file.copy(file, webOutput+filename);
		}
	};


	/**
	 * -- TEMPLATES
	 */
	var launchTemplatesBuild = function(targets, configuration, targetName){
		// if no target is provided, stop process
		if(!targets){
			grunt.log.writeln("There is not any target");
			return true;
		}

		// get references to possible targets 
		var android = targets.android;
		var ios = targets.ios;
		var web = targets.web;

		// if all targets are excluded, stop process
		if(!android && !ios && !web){
			grunt.log.writeln("All targets are excluded");
			return true;
		}

		var config = grunt.config.data;
		// get the existing hogan config, or a new one 
		config["hogan"] = config["hogan"] || {};
		// get a reference to the configuration of hogan
		var hogan = config["hogan"];
		// create and initialize the default target
		var target = {};
		// Create array of Hogan Targets
		var nubornHoganTargets = [];
		// define a default hogan configuration
		var defaultConfiguration = {
			namespace: "Templates",
			prettify: true,
			defaultName: function(fileName) {
				var name = nodePath.basename(fileName, nodePath.extname(fileName));
				var module = nodePath.basename(nodePath.dirname(nodePath.dirname(fileName)));
				return module+"_"+name;
			}
		};
		// create the target options
		target.options = jQueryExtend(true, {}, defaultConfiguration, configuration.options);
		// Create the sources 
		var targetSources = [].concat(configuration.patterns ? configuration.patterns : []);
		if(!targetSources.length){
			grunt.log.writeln("Patterns directive is empty.");
			return false;
		}
		// initialize files directive
		target.files = {
			"src/nuborn-hogan.js": targetSources
		};
		// register the target to the task
		hogan["nuborn-target"] = target;
		// run the hogan task
		grunt.task.run("hogan:nuborn-target");
	};


	/**
	 * Simple add a slash to a dir if there is not
	 */
	var addSeparatorToPath = function(path){
		var dir = path
		if(dir.charAt(dir.length-1) !== sep){
			dir = dir+sep;
		}
		return dir;
	};

	/**
	 * The jQuery Extend method too easily extend configurations
	 */
	 var jQueryExtend = function() {
		var src, copyIsArray, copy, name, options, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
			target = arguments[1] || {};
			// skip the boolean and the target
			i = 2;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && typeof target !== 'function' ) {
			target = {};
		}

		// extend jQuery itself if only one argument is passed
		if ( length === i ) {
			target = this;
			--i;
		}

		for ( ; i < length; i++ ) {
			// Only deal with non-null/undefined values
			if ( (options = arguments[ i ]) != null ) {
				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( (copyIsArray = Array.isArray(copy)) || (typeof copy === 'object') ) ) {
						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && Array.isArray(src) ? src : [];

						} else {
							clone = src && (!Array.isArray(src) && typeof src === 'object') ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQueryExtend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	grunt.registerTask("nuborn-copy", "Copy a file", function(source, destination){
		grunt.file.copy(source, destination);
	});

	grunt.registerTask("nuborn-delete", "Delete a file",  function(file){
		grunt.file.delete(file);
	});

	grunt.registerTask("nuborn-move", "Move a file",  function(source, destination){
		grunt.file.copy(source, destination);
		grunt.file.delete(source);
	});
};
